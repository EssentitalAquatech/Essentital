

// controllers/farmerController.js
import Farmer from "../models/farmerModel.js";
import AccessRequest from "../models/accessRequestModel.js";

// ---------------------------
// GET FARMERS BY AGENT
// ---------------------------
export const getFarmersByAgent = async (req, res) => {
  try {
    const { agentId, viewerId } = req.query;
    const allFarmers = await Farmer.find({ createdBy: agentId })
      .select("name contact village photo _id farmerId")
      .sort({ name: 1 });

    // Convert Buffer to Base64 for photo
    const farmersWithPhoto = allFarmers.map(farmer => {
      const farmerObj = farmer.toObject();
      if (farmerObj.photo && Buffer.isBuffer(farmerObj.photo)) {
        farmerObj.photo = `data:image/jpeg;base64,${farmerObj.photo.toString('base64')}`;
      }
      return farmerObj;
    });

    const farmersWithAccess = await Promise.all(
      farmersWithPhoto.map(async (farmer) => {
        const access = await AccessRequest.findOne({
          requesterId: viewerId,
          targetFarmerId: farmer._id,
          status: "approved",
        });

        return {
          ...farmer,
          accessApproved: !!access
        };
      })
    );

    res.json({
      approved: farmersWithAccess.some(f => f.accessApproved),
      farmers: farmersWithAccess
    });
  } catch (err) {
    console.error("ðŸ”¥ GET FARMERS BY AGENT ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// ADD FARMER (Buffer Files) - SIMPLIFIED VERSION
// ---------------------------
export const addFarmer = async (req, res) => {
  try {
    console.log("ðŸ“ ADD FARMER REQUEST BODY:", req.body);
    console.log("ðŸ“¸ FILES:", req.files);

    const { name, contact, age, gender, village, pondCount, adhar, familyMembers, familyOccupation, userId } = req.body;

    // Validation
    const requiredFields = ['name','contact','age','gender','village','adhar','familyMembers','familyOccupation'];
    const missingFields = requiredFields.filter(f => !req.body[f]);
    if (missingFields.length) return res.status(400).json({ error: `Missing fields: ${missingFields.join(', ')}` });

    // ðŸ“ž Phone validation
    if (!/^\d{10}$/.test(contact)) {
      return res.status(400).json({
        error: "Phone number must be exactly 10 digits and numeric only"
      });
    }

    // ðŸ†” Aadhar validation
    if (!/^\d{12}$/.test(adhar)) {
      return res.status(400).json({
        error: "Aadhar number must be exactly 12 digits and numeric only"
      });
    }

    // Files in Buffer
    const photo = req.files?.photo?.[0]?.buffer || null;

    // Validate required files
    if (!photo) return res.status(400).json({ error: "Farmer photo is required" });

    // Pond array - FIXED: ponds à¤•à¥‹ required field à¤¹à¥ˆ, à¤‡à¤¸à¤²à¤¿à¤ empty array à¤¦à¥‡à¤‚
    const totalPonds = parseInt(pondCount || 0);
    const pondsArray = []; // âœ… Empty array for now
    
    // âœ… ADD LATITUDE/LONGITUDE VALIDATION BLOCK
    if (totalPonds > 0) {
      for (let i = 1; i <= totalPonds; i++) {
        if (!req.body[`latitude${i}`] || !req.body[`longitude${i}`]) {
          return res.status(400).json({
            error: `Latitude & Longitude required for pond ${i}`
          });
        }
        
        // Optional: Validate numeric range
        const lat = Number(req.body[`latitude${i}`]);
        const lng = Number(req.body[`longitude${i}`]);
        
        if (isNaN(lat) || lat < -90 || lat > 90) {
          return res.status(400).json({
            error: `Invalid latitude for pond ${i}. Must be between -90 and 90`
          });
        }
        
        if (isNaN(lng) || lng < -180 || lng > 180) {
          return res.status(400).json({
            error: `Invalid longitude for pond ${i}. Must be between -180 and 180`
          });
        }
      }
    }
    
    // âŒ NO FARMER ID GENERATION HERE - MODEL WILL HANDLE IT AUTOMATICALLY
    console.log("âœ… farmerId will be auto-generated by model");

    // Create ponds if any (for future use when pondCount > 0)
    if (totalPonds > 0) {
      const pondImage = req.files?.pondImage?.[0]?.buffer || null;
      const pondFiles = req.files?.pondFiles?.map(f => f.buffer) || [];
      const fishFiles = req.files?.fishFiles?.map(f => f.buffer) || [];
      
      for (let i = 1; i <= totalPonds; i++) {
        // ðŸ”¥ðŸ”¥ðŸ”¥ LATITUDE & LONGITUDE (SAFE CONVERSION)
        const lat = parseFloat(req.body[`latitude${i}`]);
        const lng = parseFloat(req.body[`longitude${i}`]);

        if (Number.isNaN(lat) || Number.isNaN(lng)) {
          return res.status(400).json({
            error: `Invalid latitude/longitude for pond ${i}`
          });
        }

        // ðŸ§ª OPTIONAL (1 line debug â€“ ek baar check kar lo)
        console.log("ðŸ“ Saving pond location:", lat, lng);
        
        const pondData = {
          pondId: `P${i}`, // Temporary ID, will be updated after farmerId is generated
          pondNumber: i,
          pondArea: req.body[`pondArea${i}`] || "",
          pondAreaUnit: req.body[`pondAreaUnit${i}`] || "acre",
          pondDepth: req.body[`pondDepth${i}`] || "",
          pondImage: pondImage || Buffer.from([]),
          
          // âœ… SAFE LATITUDE & LONGITUDE
          latitude: lat,
          longitude: lng,
          
          overflow: req.body[`overflow${i}`] || "No",
          receivesSunlight: req.body[`receivesSunlight${i}`] || "Yes",
          treesOnBanks: req.body[`treesOnBanks${i}`] || "No",
          neighbourhood: req.body[`neighbourhood${i}`] || "Agriculture Farm",
          wastewaterEnters: req.body[`wastewaterEnters${i}`] || "No",
          
          species: req.body[`species${i}`] || "",
          dateOfStocking: req.body[`dateOfStocking${i}`] || new Date(),
          qtySeedInitially: req.body[`qtySeedInitially${i}`] || "",
          currentQty: req.body[`currentQty${i}`] || "",
          avgSize: req.body[`avgSize${i}`] || ">200gram",
          
          feedType: req.body[`feedType${i}`] || "Market Feed",
          feedOther: req.body[`feedOther${i}`] || "",
          feedFreq: req.body[`feedFreq${i}`] || "Once a day",
          feedQtyPerDay: req.body[`feedQtyPerDay${i}`] || "",
          feedTime: req.body[`feedTime${i}`] || "6:00 am-10:00am",
          recentFeedChanges: req.body[`recentFeedChanges${i}`] || "",
          reducedAppetite: req.body[`reducedAppetite${i}`] || "No",
          
          waterTemperature: req.body[`waterTemperature${i}`] || "",
          pH: req.body[`pH${i}`] || "",
          DO: req.body[`DO${i}`] || "",
          ammoniaLevel: req.body[`ammoniaLevel${i}`] || "Medium",
          phytoplanktonLevel: req.body[`phytoplanktonLevel${i}`] || "Medium",
          waterHardness: req.body[`waterHardness${i}`] || "1",
          algaeBloom: req.body[`algaeBloom${i}`] || "No",
          pondWaterColor: req.body[`pondWaterColor${i}`] || "Light Green",
          sourceOfWater: req.body[`sourceOfWater${i}`] || "Rainwater",
          
          diseaseSymptoms: req.body[`diseaseSymptoms${i}`] || "No",
          symptomsObserved: req.body[`symptomsObserved${i}`] || "",
          fishDeaths: req.body[`fishDeaths${i}`] || "",
          symptomsAffect: req.body[`symptomsAffect${i}`] || "All",
          
          farmObservedDate: req.body[`farmObservedDate${i}`] || new Date(),
          farmObservedTime: req.body[`farmObservedTime${i}`] || "",
          
          lastSpecies: req.body[`lastSpecies${i}`] || "",
          lastHarvestComplete: req.body[`lastHarvestComplete${i}`] || "Yes",
          recentRainFlood: req.body[`recentRainFlood${i}`] || "No",
          pesticideRunoff: req.body[`pesticideRunoff${i}`] || "No",
          constructionNear: req.body[`constructionNear${i}`] || "No",
          suddenTempChange: req.body[`suddenTempChange${i}`] || "No",
          
          notes: req.body[`notes${i}`] || "",
          
          pondFiles: pondFiles,
          fishFiles: fishFiles,
          
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        pondsArray.push(pondData);
      }
    }

    // âœ… CREATE FARMER WITHOUT MANUAL farmerId
    const newFarmer = new Farmer({
      // âŒ NO farmerId HERE - MODEL PRE-SAVE HOOK WILL GENERATE IT
      userId,
      createdBy: userId,
      name, 
      contact, 
      age, 
      gender, 
      village,
      pondCount: totalPonds,
      adhar, 
      familyMembers, 
      familyOccupation,
      photo,
      pondFiles: totalPonds > 0 ? (req.files?.pondFiles?.map(f => f.buffer) || []) : [],
      fishFiles: totalPonds > 0 ? (req.files?.fishFiles?.map(f => f.buffer) || []) : [],
      ponds: pondsArray, // âœ… Required field - can be empty array
      updates: [] // âœ… Empty array
    });

    console.log("ðŸ“‹ Farmer object before save:", {
      name: newFarmer.name,
      pondCount: newFarmer.pondCount,
      hasPhoto: !!newFarmer.photo,
      pondsCount: newFarmer.ponds.length,
      // farmerId will be undefined here - that's OK
    });

    // Save farmer (model's pre-save hook will generate farmerId)
    await newFarmer.save();
    console.log("âœ… Farmer saved successfully. Auto-generated farmerId:", newFarmer.farmerId);
    
    // Now that farmerId is generated, update pondIds if needed
    if (newFarmer.farmerId && newFarmer.ponds.length > 0) {
      newFarmer.ponds.forEach((pond, index) => {
        pond.pondId = `${newFarmer.farmerId}-P${index + 1}`;
      });
      await newFarmer.save();
    }
    
    // Convert buffer to base64 for response
    const responseFarmer = newFarmer.toObject();
    if (responseFarmer.photo) {
      responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
    }
    
    res.status(201).json(responseFarmer);

  } catch (err) {
    console.error("ðŸ”¥ ADD FARMER ERROR:", err);
    res.status(500).json({ 
      error: err.message,
      details: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }
};

// ---------------------------
// GET FARMERS - WITH SELFIE CONVERSION
// ---------------------------
export const getFarmers = async (req, res) => {
  try {
    const farmers = await Farmer.find({ createdBy: req.query.userId });
    
    // Convert buffers to base64
    const farmersWithBase64 = farmers.map(farmer => {
      const farmerObj = farmer.toObject();
      if (farmerObj.photo) {
        farmerObj.photo = `data:image/jpeg;base64,${farmerObj.photo.toString('base64')}`;
      }
      
      // Convert pond images and selfies
      if (farmerObj.ponds && farmerObj.ponds.length > 0) {
        farmerObj.ponds = farmerObj.ponds.map(pond => {
          if (pond.pondImage && Buffer.isBuffer(pond.pondImage)) {
            pond.pondImage = `data:image/jpeg;base64,${pond.pondImage.toString('base64')}`;
          }
          // âœ… CONVERT SELFIE
          if (pond.uploadSelfie && Buffer.isBuffer(pond.uploadSelfie)) {
            pond.uploadSelfie = `data:image/jpeg;base64,${pond.uploadSelfie.toString('base64')}`;
          }
          return pond;
        });
      }
      
      return farmerObj;
    });
    
    res.json(farmersWithBase64);
  } catch (err) {
    console.error("ðŸ”¥ GET FARMERS ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// GET FARMER BY ID
// ---------------------------
export const getFarmerById = async (req, res) => {
  try {
    const farmer = await Farmer.getFarmerByAnyId(req.params.id);
    if (!farmer) return res.status(404).json({ error: "Farmer not found" });
    
    // Convert buffers to base64
    const farmerObj = farmer.toObject();
    if (farmerObj.photo) {
      farmerObj.photo = `data:image/jpeg;base64,${farmerObj.photo.toString('base64')}`;
    }
    
    // Convert pond images and selfies
    if (farmerObj.ponds) {
      farmerObj.ponds = farmerObj.ponds.map(pond => {
        if (pond.pondImage && Buffer.isBuffer(pond.pondImage)) {
          pond.pondImage = `data:image/jpeg;base64,${pond.pondImage.toString('base64')}`;
        }
        // âœ… CONVERT SELFIE
        if (pond.uploadSelfie && Buffer.isBuffer(pond.uploadSelfie)) {
          pond.uploadSelfie = `data:image/jpeg;base64,${pond.uploadSelfie.toString('base64')}`;
        }
        return pond;
      });
    }
    
    res.json(farmerObj);
  } catch (err) {
    console.error("ðŸ”¥ GET FARMER ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// UPDATE FARMER (Buffer)
// ---------------------------
export const updateFarmer = async (req, res) => {
  try {
    const farmer = await Farmer.findById(req.params.id);
    if (!farmer) return res.status(404).json({ error: "Farmer not found" });

    // ðŸ“ž Phone validation (if contact is being updated)
    if (req.body.contact && !/^\d{10}$/.test(req.body.contact)) {
      return res.status(400).json({
        error: "Phone number must be exactly 10 digits and numeric only"
      });
    }

    // ðŸ†” Aadhar validation (if adhar is being updated)
    if (req.body.adhar && !/^\d{12}$/.test(req.body.adhar)) {
      return res.status(400).json({
        error: "Aadhar number must be exactly 12 digits and numeric only"
      });
    }

    // Save old data for history
    const oldFarmerData = farmer.toObject();

    // Update fields
    Object.keys(req.body).forEach(key => { 
      if (req.body[key] !== undefined && 
          !['farmerId', '_id', 'createdAt', 'updatedAt'].includes(key)) {
        farmer[key] = req.body[key]; 
      }
    });

    // Update buffers
    if (req.files?.photo) farmer.photo = req.files.photo[0].buffer;
    
    // Update pond images if new pondImage uploaded
    if (req.files?.pondImage && farmer.ponds.length > 0) {
      farmer.ponds.forEach(pond => {
        pond.pondImage = req.files.pondImage[0].buffer;
      });
    }
    
    if (req.files?.pondFiles) farmer.pondFiles.push(...req.files.pondFiles.map(f => f.buffer));
    if (req.files?.fishFiles) farmer.fishFiles.push(...req.files.fishFiles.map(f => f.buffer));

    // Track changes for history
    const changes = {};
    Object.keys(req.body).forEach(key => {
      if (!['userId', 'farmerId'].includes(key) && 
          oldFarmerData[key] != req.body[key]) {
        changes[key] = {
          old: oldFarmerData[key] || "N/A",
          new: req.body[key]
        };
      }
    });

    // Add to updates history
    if (Object.keys(changes).length > 0) {
      farmer.updates.push({
        snapshot: oldFarmerData,
        changes,
        pondFiles: req.files?.pondFiles?.map(f => f.buffer) || [],
        fishFiles: req.files?.fishFiles?.map(f => f.buffer) || [],
        updatedBy: req.body.userId || farmer.userId,
        createdAt: new Date()
      });
    }

    await farmer.save();
    
    // Convert buffer to base64 for response
    const responseFarmer = farmer.toObject();
    if (responseFarmer.photo) {
      responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
    }
    
    res.json(responseFarmer);
  } catch (err) {
    console.error("ðŸ”¥ UPDATE FARMER ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// ADD POND TO FARMER
// ---------------------------
export const addPondToFarmer = async (req, res) => {
  try {
    const { farmerId } = req.params;
    const pondData = req.body;

    const farmer = await Farmer.getFarmerByAnyId(farmerId);
    if (!farmer)
      return res.status(404).json({ error: "Farmer not found" });

    // âœ… ADD LATITUDE/LONGITUDE VALIDATION FOR NEW POND
    if (!pondData.latitude || !pondData.longitude) {
      return res.status(400).json({
        error: "Latitude & Longitude are required for pond"
      });
    }
    
    // Validate numeric range
    const lat = parseFloat(pondData.latitude);
    const lng = parseFloat(pondData.longitude);
    
    if (Number.isNaN(lat) || lat < -90 || lat > 90) {
      return res.status(400).json({
        error: "Invalid latitude. Must be between -90 and 90"
      });
    }
    
    if (Number.isNaN(lng) || lng < -180 || lng > 180) {
      return res.status(400).json({
        error: "Invalid longitude. Must be between -180 and 180"
      });
    }

    // Validate required fields
    const requiredPondFields = [
      'pondArea', 'pondDepth', 'species', 'dateOfStocking', 
      'qtySeedInitially', 'currentQty', 'waterTemperature', 'pH', 'DO',
      'farmObservedDate', 'farmObservedTime'
    ];
    
    for (const field of requiredPondFields) {
      if (!pondData[field]) {
        return res.status(400).json({ 
          error: `Please fill required field: ${field.replace(/([A-Z])/g, ' $1').toLowerCase()}` 
        });
      }
    }

    const pondNumber = farmer.ponds.length > 0 
      ? Math.max(...farmer.ponds.map(p => p.pondNumber)) + 1 
      : 1;
    
    // Use farmer.farmerId (auto-generated by model)
    const newPondId = `${farmer.farmerId}-P${pondNumber}`;

    // Create new pond object
    const newPond = {
      pondId: newPondId,
      pondNumber,
      ...pondData,
      // âœ… SAFE latitude/longitude conversion
      latitude: lat,
      longitude: lng,
      pondImage: req.files?.pondImage?.[0]?.buffer || Buffer.from([]),
      pondFiles: req.files?.pondFiles?.map(f => f.buffer) || [],
      fishFiles: req.files?.fishFiles?.map(f => f.buffer) || [],
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Add pond to farmer
    farmer.ponds.push(newPond);
    farmer.pondCount = farmer.ponds.length;

    await farmer.save();

    // Convert buffers to base64 for response
    const responseFarmer = farmer.toObject();
    if (responseFarmer.photo) {
      responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
    }

    res.json({ success: true, farmer: responseFarmer });
  } catch (err) {
    console.error("ADD POND ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// UPDATE POND
// ---------------------------
export const updatePond = async (req, res) => {
  try {
    const { farmerId, pondId } = req.params;
    const updateData = req.body;

    const farmer = await Farmer.getFarmerByAnyId(farmerId);
    if (!farmer)
      return res.status(404).json({ error: "Farmer not found" });

    const pondIndex = farmer.ponds.findIndex(
      p => p.pondId === pondId
    );
    
    if (pondIndex === -1)
      return res.status(404).json({ error: "Pond not found" });

    // âœ… VALIDATE LATITUDE/LONGITUDE IF PROVIDED IN UPDATE
    if (updateData.latitude !== undefined || updateData.longitude !== undefined) {
      const lat = updateData.latitude !== undefined ? parseFloat(updateData.latitude) : farmer.ponds[pondIndex].latitude;
      const lng = updateData.longitude !== undefined ? parseFloat(updateData.longitude) : farmer.ponds[pondIndex].longitude;
      
      if (updateData.latitude !== undefined && (Number.isNaN(lat) || lat < -90 || lat > 90)) {
        return res.status(400).json({
          error: "Invalid latitude. Must be between -90 and 90"
        });
      }
      
      if (updateData.longitude !== undefined && (Number.isNaN(lng) || lng < -180 || lng > 180)) {
        return res.status(400).json({
          error: "Invalid longitude. Must be between -180 and 180"
        });
      }
    }

    /* ===============================
       DATE SAFETY
    ================================ */
    if (updateData.dateOfStocking) {
      updateData.dateOfStocking = new Date(updateData.dateOfStocking);
    }
    if (updateData.farmObservedDate) {
      updateData.farmObservedDate = new Date(updateData.farmObservedDate);
    }

    /* ===============================
       ðŸ”¥ SAVE POND HISTORY
    ================================ */
    const oldPond = JSON.parse(JSON.stringify(farmer.ponds[pondIndex]));
    const changes = {};

    Object.keys(updateData).forEach(key => {
      if (oldPond[key] != updateData[key]) {
        changes[`pond.${key}`] = {
          old: oldPond[key] || "N/A",
          new: updateData[key]
        };
      }
    });

    if (Object.keys(changes).length > 0) {
      farmer.updates.push({
        snapshot: {
          pondId: oldPond.pondId,
          pondNumber: oldPond.pondNumber,
          ...oldPond
        },
        changes,
        pondFiles: req.files?.pondFiles?.map(f => f.buffer) || [],
        fishFiles: req.files?.fishFiles?.map(f => f.buffer) || [],
        updatedBy: updateData.userId || farmer.userId,
        createdAt: new Date()
      });
    }

    /* ===============================
       UPDATE POND (ID SAFE)
    ================================ */
    farmer.ponds[pondIndex] = {
      ...oldPond,

      // ðŸ”’ pondId & pondNumber NEVER CHANGE
      pondId: oldPond.pondId,
      pondNumber: oldPond.pondNumber,

      ...updateData,

      // âœ… SAFE latitude/longitude conversion
      latitude: updateData.latitude !== undefined ? parseFloat(updateData.latitude) : oldPond.latitude,
      longitude: updateData.longitude !== undefined ? parseFloat(updateData.longitude) : oldPond.longitude,

      pondImage:
        req.files?.pondImage?.[0]?.buffer ||
        oldPond.pondImage,

      pondFiles: req.files?.pondFiles
        ? req.files.pondFiles.map(f => f.buffer)
        : oldPond.pondFiles,

      fishFiles: req.files?.fishFiles
        ? req.files.fishFiles.map(f => f.buffer)
        : oldPond.fishFiles,

      updatedAt: new Date()
    };

    await farmer.save();

    // Convert buffers to base64 for response
    const responseFarmer = farmer.toObject();
    if (responseFarmer.photo) {
      responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
    }

    res.json({ success: true, farmer: responseFarmer });
  } catch (err) {
    console.error("UPDATE POND ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};




//  ye uper vala sahi hai 









