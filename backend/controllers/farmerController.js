

// // controllers/farmerController.js
// import Farmer from "../models/farmerModel.js";
// import AccessRequest from "../models/accessRequestModel.js";

// // ---------------------------
// // GET FARMERS BY AGENT
// // ---------------------------
// export const getFarmersByAgent = async (req, res) => {
//   try {
//     const { agentId, viewerId } = req.query;
//     const allFarmers = await Farmer.find({ createdBy: agentId })
//       .select("name contact village photo _id farmerId")
//       .sort({ name: 1 });

//     // Convert Buffer to Base64 for photo
//     const farmersWithPhoto = allFarmers.map(farmer => {
//       const farmerObj = farmer.toObject();
//       if (farmerObj.photo && Buffer.isBuffer(farmerObj.photo)) {
//         farmerObj.photo = `data:image/jpeg;base64,${farmerObj.photo.toString('base64')}`;
//       }
//       return farmerObj;
//     });

//     const farmersWithAccess = await Promise.all(
//       farmersWithPhoto.map(async (farmer) => {
//         const access = await AccessRequest.findOne({
//           requesterId: viewerId,
//           targetFarmerId: farmer._id,
//           status: "approved",
//         });

//         return {
//           ...farmer,
//           accessApproved: !!access
//         };
//       })
//     );

//     res.json({
//       approved: farmersWithAccess.some(f => f.accessApproved),
//       farmers: farmersWithAccess
//     });
//   } catch (err) {
//     console.error("ðŸ”¥ GET FARMERS BY AGENT ERROR:", err);
//     res.status(500).json({ error: err.message });
//   }
// };

// // ---------------------------
// // ADD FARMER (Buffer Files) - SIMPLIFIED VERSION
// // ---------------------------
// export const addFarmer = async (req, res) => {
//   try {
//     console.log("ðŸ“ ADD FARMER REQUEST BODY:", req.body);
//     console.log("ðŸ“¸ FILES:", req.files);

//     const { name, contact, age, gender, village, pondCount, adhar, familyMembers, familyOccupation, userId } = req.body;

//     // Validation
//     const requiredFields = ['name','contact','age','gender','village','adhar','familyMembers','familyOccupation'];
//     const missingFields = requiredFields.filter(f => !req.body[f]);
//     if (missingFields.length) return res.status(400).json({ error: `Missing fields: ${missingFields.join(', ')}` });

//     // ðŸ“ž Phone validation
//     if (!/^\d{10}$/.test(contact)) {
//       return res.status(400).json({
//         error: "Phone number must be exactly 10 digits and numeric only"
//       });
//     }

//     // ðŸ†” Aadhar validation
//     if (!/^\d{12}$/.test(adhar)) {
//       return res.status(400).json({
//         error: "Aadhar number must be exactly 12 digits and numeric only"
//       });
//     }

//     // Files in Buffer
//     const photo = req.files?.photo?.[0]?.buffer || null;

//     // Validate required files
//     if (!photo) return res.status(400).json({ error: "Farmer photo is required" });

//     // Pond array - FIXED: ponds à¤•à¥‹ required field à¤¹à¥ˆ, à¤‡à¤¸à¤²à¤¿à¤ empty array à¤¦à¥‡à¤‚
//     const totalPonds = parseInt(pondCount || 0);
//     const pondsArray = []; // âœ… Empty array for now
    
//     // âœ… ADD LATITUDE/LONGITUDE VALIDATION BLOCK
//     if (totalPonds > 0) {
//       for (let i = 1; i <= totalPonds; i++) {
//         if (!req.body[`latitude${i}`] || !req.body[`longitude${i}`]) {
//           return res.status(400).json({
//             error: `Latitude & Longitude required for pond ${i}`
//           });
//         }
        
//         // Optional: Validate numeric range
//         const lat = Number(req.body[`latitude${i}`]);
//         const lng = Number(req.body[`longitude${i}`]);
        
//         if (isNaN(lat) || lat < -90 || lat > 90) {
//           return res.status(400).json({
//             error: `Invalid latitude for pond ${i}. Must be between -90 and 90`
//           });
//         }
        
//         if (isNaN(lng) || lng < -180 || lng > 180) {
//           return res.status(400).json({
//             error: `Invalid longitude for pond ${i}. Must be between -180 and 180`
//           });
//         }
//       }
//     }
    
//     // âŒ NO FARMER ID GENERATION HERE - MODEL WILL HANDLE IT AUTOMATICALLY
//     console.log("âœ… farmerId will be auto-generated by model");

//     // Create ponds if any (for future use when pondCount > 0)
//     if (totalPonds > 0) {
//       const pondImage = req.files?.pondImage?.[0]?.buffer || null;
//       const pondFiles = req.files?.pondFiles?.map(f => f.buffer) || [];
//       const fishFiles = req.files?.fishFiles?.map(f => f.buffer) || [];
      
//       for (let i = 1; i <= totalPonds; i++) {
//         // ðŸ”¥ðŸ”¥ðŸ”¥ LATITUDE & LONGITUDE (SAFE CONVERSION)
//         const lat = parseFloat(req.body[`latitude${i}`]);
//         const lng = parseFloat(req.body[`longitude${i}`]);

//         if (Number.isNaN(lat) || Number.isNaN(lng)) {
//           return res.status(400).json({
//             error: `Invalid latitude/longitude for pond ${i}`
//           });
//         }

//         // ðŸ§ª OPTIONAL (1 line debug â€“ ek baar check kar lo)
//         console.log("ðŸ“ Saving pond location:", lat, lng);
        
//         const pondData = {
//           pondId: `P${i}`, // Temporary ID, will be updated after farmerId is generated
//           pondNumber: i,
//           pondArea: req.body[`pondArea${i}`] || "",
//           pondAreaUnit: req.body[`pondAreaUnit${i}`] || "acre",
//           pondDepth: req.body[`pondDepth${i}`] || "",
//           pondImage: pondImage || Buffer.from([]),
          
//           // âœ… SAFE LATITUDE & LONGITUDE
//           latitude: lat,
//           longitude: lng,
          
//           overflow: req.body[`overflow${i}`] || "No",
//           receivesSunlight: req.body[`receivesSunlight${i}`] || "Yes",
//           treesOnBanks: req.body[`treesOnBanks${i}`] || "No",
//           neighbourhood: req.body[`neighbourhood${i}`] || "Agriculture Farm",
//           wastewaterEnters: req.body[`wastewaterEnters${i}`] || "No",
          
//           species: req.body[`species${i}`] || "",
//           dateOfStocking: req.body[`dateOfStocking${i}`] || new Date(),
//           qtySeedInitially: req.body[`qtySeedInitially${i}`] || "",
//           currentQty: req.body[`currentQty${i}`] || "",
//           avgSize: req.body[`avgSize${i}`] || ">200gram",
          
//           feedType: req.body[`feedType${i}`] || "Market Feed",
//           feedOther: req.body[`feedOther${i}`] || "",
//           feedFreq: req.body[`feedFreq${i}`] || "Once a day",
//           feedQtyPerDay: req.body[`feedQtyPerDay${i}`] || "",
//           feedTime: req.body[`feedTime${i}`] || "6:00 am-10:00am",
//           recentFeedChanges: req.body[`recentFeedChanges${i}`] || "",
//           reducedAppetite: req.body[`reducedAppetite${i}`] || "No",
          
//           waterTemperature: req.body[`waterTemperature${i}`] || "",
//           pH: req.body[`pH${i}`] || "",
//           DO: req.body[`DO${i}`] || "",
//           ammoniaLevel: req.body[`ammoniaLevel${i}`] || "Medium",
//           phytoplanktonLevel: req.body[`phytoplanktonLevel${i}`] || "Medium",
//           waterHardness: req.body[`waterHardness${i}`] || "1",
//           algaeBloom: req.body[`algaeBloom${i}`] || "No",
//           pondWaterColor: req.body[`pondWaterColor${i}`] || "Light Green",
//           sourceOfWater: req.body[`sourceOfWater${i}`] || "Rainwater",
          
//           diseaseSymptoms: req.body[`diseaseSymptoms${i}`] || "No",
//           symptomsObserved: req.body[`symptomsObserved${i}`] || "",
//           fishDeaths: req.body[`fishDeaths${i}`] || "",
//           symptomsAffect: req.body[`symptomsAffect${i}`] || "All",
          
//           farmObservedDate: req.body[`farmObservedDate${i}`] || new Date(),
//           farmObservedTime: req.body[`farmObservedTime${i}`] || "",
          
//           lastSpecies: req.body[`lastSpecies${i}`] || "",
//           lastHarvestComplete: req.body[`lastHarvestComplete${i}`] || "Yes",
//           recentRainFlood: req.body[`recentRainFlood${i}`] || "No",
//           pesticideRunoff: req.body[`pesticideRunoff${i}`] || "No",
//           constructionNear: req.body[`constructionNear${i}`] || "No",
//           suddenTempChange: req.body[`suddenTempChange${i}`] || "No",
          
//           notes: req.body[`notes${i}`] || "",
          
//           pondFiles: pondFiles,
//           fishFiles: fishFiles,
          
//           createdAt: new Date(),
//           updatedAt: new Date()
//         };
        
//         pondsArray.push(pondData);
//       }
//     }

//     // âœ… CREATE FARMER WITHOUT MANUAL farmerId
//     const newFarmer = new Farmer({
//       // âŒ NO farmerId HERE - MODEL PRE-SAVE HOOK WILL GENERATE IT
//       userId,
//       createdBy: userId,
//       name, 
//       contact, 
//       age, 
//       gender, 
//       village,
//       pondCount: totalPonds,
//       adhar, 
//       familyMembers, 
//       familyOccupation,
//       photo,
//       pondFiles: totalPonds > 0 ? (req.files?.pondFiles?.map(f => f.buffer) || []) : [],
//       fishFiles: totalPonds > 0 ? (req.files?.fishFiles?.map(f => f.buffer) || []) : [],
//       ponds: pondsArray, // âœ… Required field - can be empty array
//       updates: [] // âœ… Empty array
//     });

//     console.log("ðŸ“‹ Farmer object before save:", {
//       name: newFarmer.name,
//       pondCount: newFarmer.pondCount,
//       hasPhoto: !!newFarmer.photo,
//       pondsCount: newFarmer.ponds.length,
//       // farmerId will be undefined here - that's OK
//     });

//     // Save farmer (model's pre-save hook will generate farmerId)
//     await newFarmer.save();
//     console.log("âœ… Farmer saved successfully. Auto-generated farmerId:", newFarmer.farmerId);
    
//     // Now that farmerId is generated, update pondIds if needed
//     if (newFarmer.farmerId && newFarmer.ponds.length > 0) {
//       newFarmer.ponds.forEach((pond, index) => {
//         pond.pondId = `${newFarmer.farmerId}-P${index + 1}`;
//       });
//       await newFarmer.save();
//     }
    
//     // Convert buffer to base64 for response
//     const responseFarmer = newFarmer.toObject();
//     if (responseFarmer.photo) {
//       responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
//     }
    
//     res.status(201).json(responseFarmer);

//   } catch (err) {
//     console.error("ðŸ”¥ ADD FARMER ERROR:", err);
//     res.status(500).json({ 
//       error: err.message,
//       details: process.env.NODE_ENV === 'development' ? err.stack : undefined
//     });
//   }
// };

// // ---------------------------
// // GET FARMERS - WITH SELFIE CONVERSION
// // ---------------------------
// export const getFarmers = async (req, res) => {
//   try {
//     const farmers = await Farmer.find({ createdBy: req.query.userId });
    
//     // Convert buffers to base64
//     const farmersWithBase64 = farmers.map(farmer => {
//       const farmerObj = farmer.toObject();
//       if (farmerObj.photo) {
//         farmerObj.photo = `data:image/jpeg;base64,${farmerObj.photo.toString('base64')}`;
//       }
      
//       // Convert pond images and selfies
//       if (farmerObj.ponds && farmerObj.ponds.length > 0) {
//         farmerObj.ponds = farmerObj.ponds.map(pond => {
//           if (pond.pondImage && Buffer.isBuffer(pond.pondImage)) {
//             pond.pondImage = `data:image/jpeg;base64,${pond.pondImage.toString('base64')}`;
//           }
//           // âœ… CONVERT SELFIE
//           if (pond.uploadSelfie && Buffer.isBuffer(pond.uploadSelfie)) {
//             pond.uploadSelfie = `data:image/jpeg;base64,${pond.uploadSelfie.toString('base64')}`;
//           }
//           return pond;
//         });
//       }
      
//       return farmerObj;
//     });
    
//     res.json(farmersWithBase64);
//   } catch (err) {
//     console.error("ðŸ”¥ GET FARMERS ERROR:", err);
//     res.status(500).json({ error: err.message });
//   }
// };

// // ---------------------------
// // GET FARMER BY ID
// // ---------------------------
// export const getFarmerById = async (req, res) => {
//   try {
//     const farmer = await Farmer.getFarmerByAnyId(req.params.id);
//     if (!farmer) return res.status(404).json({ error: "Farmer not found" });
    
//     // Convert buffers to base64
//     const farmerObj = farmer.toObject();
//     if (farmerObj.photo) {
//       farmerObj.photo = `data:image/jpeg;base64,${farmerObj.photo.toString('base64')}`;
//     }
    
//     // Convert pond images and selfies
//     if (farmerObj.ponds) {
//       farmerObj.ponds = farmerObj.ponds.map(pond => {
//         if (pond.pondImage && Buffer.isBuffer(pond.pondImage)) {
//           pond.pondImage = `data:image/jpeg;base64,${pond.pondImage.toString('base64')}`;
//         }
//         // âœ… CONVERT SELFIE
//         if (pond.uploadSelfie && Buffer.isBuffer(pond.uploadSelfie)) {
//           pond.uploadSelfie = `data:image/jpeg;base64,${pond.uploadSelfie.toString('base64')}`;
//         }
//         return pond;
//       });
//     }
    
//     res.json(farmerObj);
//   } catch (err) {
//     console.error("ðŸ”¥ GET FARMER ERROR:", err);
//     res.status(500).json({ error: err.message });
//   }
// };

// // ---------------------------
// // UPDATE FARMER (Buffer)
// // ---------------------------
// export const updateFarmer = async (req, res) => {
//   try {
//     const farmer = await Farmer.findById(req.params.id);
//     if (!farmer) return res.status(404).json({ error: "Farmer not found" });

//     // ðŸ“ž Phone validation (if contact is being updated)
//     if (req.body.contact && !/^\d{10}$/.test(req.body.contact)) {
//       return res.status(400).json({
//         error: "Phone number must be exactly 10 digits and numeric only"
//       });
//     }

//     // ðŸ†” Aadhar validation (if adhar is being updated)
//     if (req.body.adhar && !/^\d{12}$/.test(req.body.adhar)) {
//       return res.status(400).json({
//         error: "Aadhar number must be exactly 12 digits and numeric only"
//       });
//     }

//     // Save old data for history
//     const oldFarmerData = farmer.toObject();

//     // Update fields
//     Object.keys(req.body).forEach(key => { 
//       if (req.body[key] !== undefined && 
//           !['farmerId', '_id', 'createdAt', 'updatedAt'].includes(key)) {
//         farmer[key] = req.body[key]; 
//       }
//     });

//     // Update buffers
//     if (req.files?.photo) farmer.photo = req.files.photo[0].buffer;
    
//     // Update pond images if new pondImage uploaded
//     if (req.files?.pondImage && farmer.ponds.length > 0) {
//       farmer.ponds.forEach(pond => {
//         pond.pondImage = req.files.pondImage[0].buffer;
//       });
//     }
    
//     if (req.files?.pondFiles) farmer.pondFiles.push(...req.files.pondFiles.map(f => f.buffer));
//     if (req.files?.fishFiles) farmer.fishFiles.push(...req.files.fishFiles.map(f => f.buffer));

//     // Track changes for history
//     const changes = {};
//     Object.keys(req.body).forEach(key => {
//       if (!['userId', 'farmerId'].includes(key) && 
//           oldFarmerData[key] != req.body[key]) {
//         changes[key] = {
//           old: oldFarmerData[key] || "N/A",
//           new: req.body[key]
//         };
//       }
//     });

//     // Add to updates history
//     if (Object.keys(changes).length > 0) {
//       farmer.updates.push({
//         snapshot: oldFarmerData,
//         changes,
//         pondFiles: req.files?.pondFiles?.map(f => f.buffer) || [],
//         fishFiles: req.files?.fishFiles?.map(f => f.buffer) || [],
//         updatedBy: req.body.userId || farmer.userId,
//         createdAt: new Date()
//       });
//     }

//     await farmer.save();
    
//     // Convert buffer to base64 for response
//     const responseFarmer = farmer.toObject();
//     if (responseFarmer.photo) {
//       responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
//     }
    
//     res.json(responseFarmer);
//   } catch (err) {
//     console.error("ðŸ”¥ UPDATE FARMER ERROR:", err);
//     res.status(500).json({ error: err.message });
//   }
// };

// // ---------------------------
// // ADD POND TO FARMER
// // ---------------------------
// export const addPondToFarmer = async (req, res) => {
//   try {
//     const { farmerId } = req.params;
//     const pondData = req.body;

//     const farmer = await Farmer.getFarmerByAnyId(farmerId);
//     if (!farmer)
//       return res.status(404).json({ error: "Farmer not found" });

//     // âœ… ADD LATITUDE/LONGITUDE VALIDATION FOR NEW POND
//     if (!pondData.latitude || !pondData.longitude) {
//       return res.status(400).json({
//         error: "Latitude & Longitude are required for pond"
//       });
//     }
    
//     // Validate numeric range
//     const lat = parseFloat(pondData.latitude);
//     const lng = parseFloat(pondData.longitude);
    
//     if (Number.isNaN(lat) || lat < -90 || lat > 90) {
//       return res.status(400).json({
//         error: "Invalid latitude. Must be between -90 and 90"
//       });
//     }
    
//     if (Number.isNaN(lng) || lng < -180 || lng > 180) {
//       return res.status(400).json({
//         error: "Invalid longitude. Must be between -180 and 180"
//       });
//     }

//     // Validate required fields
//     const requiredPondFields = [
//       'pondArea', 'pondDepth', 'species', 'dateOfStocking', 
//       'qtySeedInitially', 'currentQty', 'waterTemperature', 'pH', 'DO',
//       'farmObservedDate', 'farmObservedTime'
//     ];
    
//     for (const field of requiredPondFields) {
//       if (!pondData[field]) {
//         return res.status(400).json({ 
//           error: `Please fill required field: ${field.replace(/([A-Z])/g, ' $1').toLowerCase()}` 
//         });
//       }
//     }

//     const pondNumber = farmer.ponds.length > 0 
//       ? Math.max(...farmer.ponds.map(p => p.pondNumber)) + 1 
//       : 1;
    
//     // Use farmer.farmerId (auto-generated by model)
//     const newPondId = `${farmer.farmerId}-P${pondNumber}`;

//     // Create new pond object
//     const newPond = {
//       pondId: newPondId,
//       pondNumber,
//       ...pondData,
//       // âœ… SAFE latitude/longitude conversion
//       latitude: lat,
//       longitude: lng,
//       pondImage: req.files?.pondImage?.[0]?.buffer || Buffer.from([]),
//       pondFiles: req.files?.pondFiles?.map(f => f.buffer) || [],
//       fishFiles: req.files?.fishFiles?.map(f => f.buffer) || [],
//       createdAt: new Date(),
//       updatedAt: new Date()
//     };

//     // Add pond to farmer
//     farmer.ponds.push(newPond);
//     farmer.pondCount = farmer.ponds.length;

//     await farmer.save();

//     // Convert buffers to base64 for response
//     const responseFarmer = farmer.toObject();
//     if (responseFarmer.photo) {
//       responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
//     }

//     res.json({ success: true, farmer: responseFarmer });
//   } catch (err) {
//     console.error("ADD POND ERROR:", err);
//     res.status(500).json({ error: err.message });
//   }
// };

// // ---------------------------
// // UPDATE POND
// // ---------------------------
// export const updatePond = async (req, res) => {
//   try {
//     const { farmerId, pondId } = req.params;
//     const updateData = req.body;

//     const farmer = await Farmer.getFarmerByAnyId(farmerId);
//     if (!farmer)
//       return res.status(404).json({ error: "Farmer not found" });

//     const pondIndex = farmer.ponds.findIndex(
//       p => p.pondId === pondId
//     );
    
//     if (pondIndex === -1)
//       return res.status(404).json({ error: "Pond not found" });

//     // âœ… VALIDATE LATITUDE/LONGITUDE IF PROVIDED IN UPDATE
//     if (updateData.latitude !== undefined || updateData.longitude !== undefined) {
//       const lat = updateData.latitude !== undefined ? parseFloat(updateData.latitude) : farmer.ponds[pondIndex].latitude;
//       const lng = updateData.longitude !== undefined ? parseFloat(updateData.longitude) : farmer.ponds[pondIndex].longitude;
      
//       if (updateData.latitude !== undefined && (Number.isNaN(lat) || lat < -90 || lat > 90)) {
//         return res.status(400).json({
//           error: "Invalid latitude. Must be between -90 and 90"
//         });
//       }
      
//       if (updateData.longitude !== undefined && (Number.isNaN(lng) || lng < -180 || lng > 180)) {
//         return res.status(400).json({
//           error: "Invalid longitude. Must be between -180 and 180"
//         });
//       }
//     }

//     /* ===============================
//        DATE SAFETY
//     ================================ */
//     if (updateData.dateOfStocking) {
//       updateData.dateOfStocking = new Date(updateData.dateOfStocking);
//     }
//     if (updateData.farmObservedDate) {
//       updateData.farmObservedDate = new Date(updateData.farmObservedDate);
//     }

//     /* ===============================
//        ðŸ”¥ SAVE POND HISTORY
//     ================================ */
//     const oldPond = JSON.parse(JSON.stringify(farmer.ponds[pondIndex]));
//     const changes = {};

//     Object.keys(updateData).forEach(key => {
//       if (oldPond[key] != updateData[key]) {
//         changes[`pond.${key}`] = {
//           old: oldPond[key] || "N/A",
//           new: updateData[key]
//         };
//       }
//     });

//     if (Object.keys(changes).length > 0) {
//       farmer.updates.push({
//         snapshot: {
//           pondId: oldPond.pondId,
//           pondNumber: oldPond.pondNumber,
//           ...oldPond
//         },
//         changes,
//         pondFiles: req.files?.pondFiles?.map(f => f.buffer) || [],
//         fishFiles: req.files?.fishFiles?.map(f => f.buffer) || [],
//         updatedBy: updateData.userId || farmer.userId,
//         createdAt: new Date()
//       });
//     }

//     /* ===============================
//        UPDATE POND (ID SAFE)
//     ================================ */
//     farmer.ponds[pondIndex] = {
//       ...oldPond,

//       // ðŸ”’ pondId & pondNumber NEVER CHANGE
//       pondId: oldPond.pondId,
//       pondNumber: oldPond.pondNumber,

//       ...updateData,

//       // âœ… SAFE latitude/longitude conversion
//       latitude: updateData.latitude !== undefined ? parseFloat(updateData.latitude) : oldPond.latitude,
//       longitude: updateData.longitude !== undefined ? parseFloat(updateData.longitude) : oldPond.longitude,

//       pondImage:
//         req.files?.pondImage?.[0]?.buffer ||
//         oldPond.pondImage,

//       pondFiles: req.files?.pondFiles
//         ? req.files.pondFiles.map(f => f.buffer)
//         : oldPond.pondFiles,

//       fishFiles: req.files?.fishFiles
//         ? req.files.fishFiles.map(f => f.buffer)
//         : oldPond.fishFiles,

//       updatedAt: new Date()
//     };

//     await farmer.save();

//     // Convert buffers to base64 for response
//     const responseFarmer = farmer.toObject();
//     if (responseFarmer.photo) {
//       responseFarmer.photo = `data:image/jpeg;base64,${responseFarmer.photo.toString('base64')}`;
//     }

//     res.json({ success: true, farmer: responseFarmer });
//   } catch (err) {
//     console.error("UPDATE POND ERROR:", err);
//     res.status(500).json({ error: err.message });
//   }
// };




// // ye uper vala sahi hai 















import Farmer from "../models/farmerModel.js";
import AccessRequest from "../models/accessRequestModel.js";
import { 
  uploadToGridFS, 
  uploadMultipleToGridFS,
  getFileUrl,
  deleteFromGridFS,
  getFileFromGridFS
} from "../config/gridfs.js";
import mongoose from "mongoose";

// ---------------------------
// GET FARMERS BY AGENT
// ---------------------------
export const getFarmersByAgent = async (req, res) => {
  try {
    const { agentId, viewerId } = req.query;
    const allFarmers = await Farmer.find({ createdBy: agentId })
      .select("name contact village photoId photoUrl _id farmerId")
      .sort({ name: 1 });

    // Generate photo URLs
    const farmersWithPhoto = allFarmers.map(farmer => {
      const farmerObj = farmer.toObject();
      if (farmerObj.photoUrl) {
        farmerObj.photo = farmerObj.photoUrl;
      }
      return farmerObj;
    });

    const farmersWithAccess = await Promise.all(
      farmersWithPhoto.map(async (farmer) => {
        const access = await AccessRequest.findOne({
          requesterId: viewerId,
          targetFarmerId: farmer._id,
          status: "approved",
        });

        return {
          ...farmer,
          accessApproved: !!access
        };
      })
    );

    res.json({
      approved: farmersWithAccess.some(f => f.accessApproved),
      farmers: farmersWithAccess
    });
  } catch (err) {
    console.error("ðŸ”¥ GET FARMERS BY AGENT ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// ADD FARMER (WITH GridFS)
// ---------------------------
export const addFarmer = async (req, res) => {
  try {
    console.log("ðŸ“ ADD FARMER REQUEST BODY:", req.body);
    console.log("ðŸ“¸ FILES:", req.files);

    const { name, contact, age, gender, village, pondCount, adhar, familyMembers, familyOccupation, userId } = req.body;

    // Validation
    const requiredFields = ['name', 'contact', 'age', 'gender', 'village', 'adhar', 'familyMembers', 'familyOccupation'];
    const missingFields = requiredFields.filter(f => !req.body[f]);
    if (missingFields.length) {
      return res.status(400).json({ error: `Missing fields: ${missingFields.join(', ')}` });
    }

    // ðŸ“ž Phone validation
    if (!/^\d{10}$/.test(contact)) {
      return res.status(400).json({
        error: "Phone number must be exactly 10 digits and numeric only"
      });
    }

    // ðŸ†” Aadhar validation
    if (!/^\d{12}$/.test(adhar)) {
      return res.status(400).json({
        error: "Aadhar number must be exactly 12 digits and numeric only"
      });
    }

    // Upload farmer photo to GridFS
    let photoId = null;
    if (req.files?.photo?.[0]) {
      photoId = await uploadToGridFS(
        req.files.photo[0].buffer,
        req.files.photo[0].originalname,
        { 
          type: 'farmer-photo', 
          name: name,
          contact: contact,
          village: village 
        },
        'documents'
      );
    } else {
      return res.status(400).json({ error: "Farmer photo is required" });
    }

    // Calculate total ponds
    const totalPonds = parseInt(pondCount || 0);
    const pondsArray = [];
    
    // Validate latitude/longitude for each pond if ponds exist
    if (totalPonds > 0) {
      for (let i = 1; i <= totalPonds; i++) {
        if (!req.body[`latitude${i}`] || !req.body[`longitude${i}`]) {
          return res.status(400).json({
            error: `Latitude & Longitude required for pond ${i}`
          });
        }
        
        const lat = Number(req.body[`latitude${i}`]);
        const lng = Number(req.body[`longitude${i}`]);
        
        if (isNaN(lat) || lat < -90 || lat > 90) {
          return res.status(400).json({
            error: `Invalid latitude for pond ${i}. Must be between -90 and 90`
          });
        }
        
        if (isNaN(lng) || lng < -180 || lng > 180) {
          return res.status(400).json({
            error: `Invalid longitude for pond ${i}. Must be between -180 and 180`
          });
        }
      }
    }

    // Create ponds if any
    if (totalPonds > 0) {
      for (let i = 1; i <= totalPonds; i++) {
        // Upload pond image to GridFS
        let pondImageId = null;
        if (req.files?.pondImage?.[0]) {
          pondImageId = await uploadToGridFS(
            req.files.pondImage[0].buffer,
            req.files.pondImage[0].originalname,
            { 
              type: 'pond-image', 
              pondNumber: i,
              farmerName: name 
            },
            'pondImages'
          );
        }
        
        // Upload selfie if provided
        let selfieId = null;
        if (req.files?.uploadSelfie?.[0]) {
          selfieId = await uploadToGridFS(
            req.files.uploadSelfie[0].buffer,
            req.files.uploadSelfie[0].originalname,
            { 
              type: 'pond-selfie', 
              pondNumber: i,
              farmerName: name 
            },
            'pondImages'
          );
        }
        
        // Upload pond files to GridFS
        let pondFileIds = [];
        if (req.files?.pondFiles && req.files.pondFiles.length > 0) {
          pondFileIds = await uploadMultipleToGridFS(
            req.files.pondFiles,
            { 
              type: 'pond-document', 
              pondNumber: i,
              farmerName: name 
            },
            'documents'
          );
        }
        
        // Upload fish files to GridFS
        let fishFileIds = [];
        if (req.files?.fishFiles && req.files.fishFiles.length > 0) {
          fishFileIds = await uploadMultipleToGridFS(
            req.files.fishFiles,
            { 
              type: 'fish-document', 
              pondNumber: i,
              farmerName: name 
            },
            'documents'
          );
        }
        
        const lat = parseFloat(req.body[`latitude${i}`]);
        const lng = parseFloat(req.body[`longitude${i}`]);

        // Parse dates safely
        let dateOfStocking = new Date();
        if (req.body[`dateOfStocking${i}`]) {
          dateOfStocking = new Date(req.body[`dateOfStocking${i}`]);
        }
        
        let farmObservedDate = new Date();
        if (req.body[`farmObservedDate${i}`]) {
          farmObservedDate = new Date(req.body[`farmObservedDate${i}`]);
        }

        const pondData = {
          pondId: `TEMP-${i}`, // Will be updated after farmerId is generated
          pondNumber: i,
          
          pondArea: req.body[`pondArea${i}`] || "",
          pondAreaUnit: req.body[`pondAreaUnit${i}`] || "acre",
          pondDepth: req.body[`pondDepth${i}`] || "",
          
          pondImageId: pondImageId,
          pondImageUrl: pondImageId ? getFileUrl(pondImageId, 'pondImages') : null,
          
          uploadSelfieId: selfieId,
          uploadSelfieUrl: selfieId ? getFileUrl(selfieId, 'pondImages') : null,
          
          latitude: lat,
          longitude: lng,
          
          overflow: req.body[`overflow${i}`] || "No",
          receivesSunlight: req.body[`receivesSunlight${i}`] || "Yes",
          treesOnBanks: req.body[`treesOnBanks${i}`] || "No",
          neighbourhood: req.body[`neighbourhood${i}`] || "Agriculture Farm",
          wastewaterEnters: req.body[`wastewaterEnters${i}`] || "No",
          
          species: req.body[`species${i}`] || "",
          dateOfStocking: dateOfStocking,
          qtySeedInitially: req.body[`qtySeedInitially${i}`] || "",
          currentQty: req.body[`currentQty${i}`] || "",
          avgSize: req.body[`avgSize${i}`] || ">200gram",
          
          feedType: req.body[`feedType${i}`] || "Market Feed",
          feedOther: req.body[`feedOther${i}`] || "",
          feedFreq: req.body[`feedFreq${i}`] || "Once a day",
          feedQtyPerDay: req.body[`feedQtyPerDay${i}`] || "",
          feedTime: req.body[`feedTime${i}`] || "6:00 am-10:00am",
          recentFeedChanges: req.body[`recentFeedChanges${i}`] || "",
          reducedAppetite: req.body[`reducedAppetite${i}`] || "No",
          
          waterTemperature: req.body[`waterTemperature${i}`] || "",
          pH: req.body[`pH${i}`] || "",
          DO: req.body[`DO${i}`] || "",
          ammoniaLevel: req.body[`ammoniaLevel${i}`] || "Medium",
          phytoplanktonLevel: req.body[`phytoplanktonLevel${i}`] || "Medium",
          waterHardness: req.body[`waterHardness${i}`] || "1",
          algaeBloom: req.body[`algaeBloom${i}`] || "No",
          pondWaterColor: req.body[`pondWaterColor${i}`] || "Light Green",
          sourceOfWater: req.body[`sourceOfWater${i}`] || "Rainwater",
          
          diseaseSymptoms: req.body[`diseaseSymptoms${i}`] || "No",
          symptomsObserved: req.body[`symptomsObserved${i}`] || "",
          fishDeaths: req.body[`fishDeaths${i}`] || "",
          symptomsAffect: req.body[`symptomsAffect${i}`] || "All",
          
          farmObservedDate: farmObservedDate,
          farmObservedTime: req.body[`farmObservedTime${i}`] || "",
          
          lastSpecies: req.body[`lastSpecies${i}`] || "",
          lastHarvestComplete: req.body[`lastHarvestComplete${i}`] || "Yes",
          recentRainFlood: req.body[`recentRainFlood${i}`] || "No",
          pesticideRunoff: req.body[`pesticideRunoff${i}`] || "No",
          constructionNear: req.body[`constructionNear${i}`] || "No",
          suddenTempChange: req.body[`suddenTempChange${i}`] || "No",
          
          notes: req.body[`notes${i}`] || "",
          
          pondFileIds: pondFileIds,
          fishFileIds: fishFileIds,
          
          createdAt: new Date(),
          updatedAt: new Date()
        };
        
        pondsArray.push(pondData);
      }
    }

    // CREATE FARMER
    const newFarmer = new Farmer({
      userId,
      createdBy: userId,
      name, 
      contact, 
      age, 
      gender, 
      village,
      pondCount: totalPonds,
      adhar, 
      familyMembers, 
      familyOccupation,
      photoId: photoId,
      photoUrl: getFileUrl(photoId, 'documents'),
      ponds: pondsArray,
      updates: []
    });

    console.log("ðŸ“‹ Saving farmer...");
    await newFarmer.save();
    console.log("âœ… Farmer saved successfully. farmerId:", newFarmer.farmerId);
    
    // Update pondIds with actual farmerId
    if (newFarmer.farmerId && newFarmer.ponds.length > 0) {
      newFarmer.ponds.forEach((pond, index) => {
        pond.pondId = `${newFarmer.farmerId}-P${index + 1}`;
      });
      await newFarmer.save();
      console.log("âœ… Pond IDs updated");
    }
    
    // Prepare response with URLs
    const responseFarmer = newFarmer.toObject();
    responseFarmer.photo = responseFarmer.photoUrl;
    
    // Add URLs for all pond images
    if (responseFarmer.ponds) {
      responseFarmer.ponds = responseFarmer.ponds.map(pond => ({
        ...pond,
        pondImage: pond.pondImageUrl,
        uploadSelfie: pond.uploadSelfieUrl
      }));
    }
    
    // Remove binary data from response
    delete responseFarmer.pondFiles;
    delete responseFarmer.fishFiles;
    
    res.status(201).json(responseFarmer);

  } catch (err) {
    console.error("ðŸ”¥ ADD FARMER ERROR:", err);
    res.status(500).json({ 
      error: err.message,
      details: process.env.NODE_ENV === 'development' ? err.stack : undefined
    });
  }
};

// ---------------------------
// GET FARMERS
// ---------------------------
export const getFarmers = async (req, res) => {
  try {
    const farmers = await Farmer.find({ createdBy: req.query.userId });
    
    // Generate URLs
    const farmersWithUrls = farmers.map(farmer => {
      const farmerObj = farmer.toObject();
      farmerObj.photo = farmerObj.photoUrl;
      
      if (farmerObj.ponds) {
        farmerObj.ponds = farmerObj.ponds.map(pond => ({
          ...pond,
          pondImage: pond.pondImageUrl,
          uploadSelfie: pond.uploadSelfieUrl
        }));
      }
      
      // Remove binary data
      delete farmerObj.pondFiles;
      delete farmerObj.fishFiles;
      
      return farmerObj;
    });
    
    res.json(farmersWithUrls);
  } catch (err) {
    console.error("ðŸ”¥ GET FARMERS ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// GET FARMER BY ID
// ---------------------------
export const getFarmerById = async (req, res) => {
  try {
    const farmer = await Farmer.getFarmerByAnyId(req.params.id);
    if (!farmer) return res.status(404).json({ error: "Farmer not found" });
    
    const farmerObj = farmer.toObject();
    farmerObj.photo = farmerObj.photoUrl;
    
    if (farmerObj.ponds) {
      farmerObj.ponds = farmerObj.ponds.map(pond => ({
        ...pond,
        pondImage: pond.pondImageUrl,
        uploadSelfie: pond.uploadSelfieUrl
      }));
    }
    
    // Remove binary data
    delete farmerObj.pondFiles;
    delete farmerObj.fishFiles;
    
    res.json(farmerObj);
  } catch (err) {
    console.error("ðŸ”¥ GET FARMER ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// UPDATE FARMER
// ---------------------------
export const updateFarmer = async (req, res) => {
  try {
    const farmer = await Farmer.findById(req.params.id);
    if (!farmer) return res.status(404).json({ error: "Farmer not found" });

    // ðŸ“ž Phone validation
    if (req.body.contact && !/^\d{10}$/.test(req.body.contact)) {
      return res.status(400).json({
        error: "Phone number must be exactly 10 digits and numeric only"
      });
    }

    // ðŸ†” Aadhar validation
    if (req.body.adhar && !/^\d{12}$/.test(req.body.adhar)) {
      return res.status(400).json({
        error: "Aadhar number must be exactly 12 digits and numeric only"
      });
    }

    // Save old data for history
    const oldFarmerData = farmer.toObject();

    // Update photo if new one uploaded
    if (req.files?.photo?.[0]) {
      // Delete old photo from GridFS
      if (farmer.photoId) {
        await deleteFromGridFS(farmer.photoId, 'documents').catch(console.error);
      }
      
      // Upload new photo
      const photoId = await uploadToGridFS(
        req.files.photo[0].buffer,
        req.files.photo[0].originalname,
        { 
          type: 'farmer-photo', 
          name: farmer.name,
          updatedAt: new Date()
        },
        'documents'
      );
      
      farmer.photoId = photoId;
      farmer.photoUrl = getFileUrl(photoId, 'documents');
    }

    // Update fields (except protected ones)
    const protectedFields = ['farmerId', '_id', 'createdAt', 'updatedAt', 'photoId', 'photoUrl', 'ponds'];
    Object.keys(req.body).forEach(key => { 
      if (req.body[key] !== undefined && !protectedFields.includes(key)) {
        farmer[key] = req.body[key]; 
      }
    });

    // Track changes for history
    const changes = {};
    Object.keys(req.body).forEach(key => {
      if (!protectedFields.includes(key) && !['userId', 'createdBy'].includes(key)) {
        const oldValue = oldFarmerData[key];
        const newValue = req.body[key];
        if (oldValue != newValue) {
          changes[key] = {
            old: oldValue || "N/A",
            new: newValue
          };
        }
      }
    });

    // Add photo change to history
    if (req.files?.photo?.[0]) {
      changes['photo'] = {
        old: 'Previous photo',
        new: 'New photo uploaded'
      };
    }

    // Add to updates history
    if (Object.keys(changes).length > 0) {
      farmer.updates.push({
        snapshot: {
          ...oldFarmerData,
          photo: 'Previous photo', // Don't store binary in history
        },
        changes,
        updatedBy: req.body.userId || farmer.userId,
        createdAt: new Date()
      });
    }

    farmer.updatedAt = new Date();
    await farmer.save();
    
    // Prepare response
    const responseFarmer = farmer.toObject();
    responseFarmer.photo = responseFarmer.photoUrl;
    
    // Add URLs for ponds
    if (responseFarmer.ponds) {
      responseFarmer.ponds = responseFarmer.ponds.map(pond => ({
        ...pond,
        pondImage: pond.pondImageUrl,
        uploadSelfie: pond.uploadSelfieUrl
      }));
    }
    
    // Remove binary data
    delete responseFarmer.pondFiles;
    delete responseFarmer.fishFiles;
    
    res.json(responseFarmer);
  } catch (err) {
    console.error("ðŸ”¥ UPDATE FARMER ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// ADD POND TO FARMER
// ---------------------------
export const addPondToFarmer = async (req, res) => {
  try {
    const { farmerId } = req.params;
    const pondData = req.body;

    const farmer = await Farmer.getFarmerByAnyId(farmerId);
    if (!farmer) {
      return res.status(404).json({ error: "Farmer not found" });
    }

    // Validate required fields
    if (!pondData.latitude || !pondData.longitude) {
      return res.status(400).json({
        error: "Latitude & Longitude are required for pond"
      });
    }
    
    // Validate numeric range
    const lat = parseFloat(pondData.latitude);
    const lng = parseFloat(pondData.longitude);
    
    if (isNaN(lat) || lat < -90 || lat > 90) {
      return res.status(400).json({
        error: "Invalid latitude. Must be between -90 and 90"
      });
    }
    
    if (isNaN(lng) || lng < -180 || lng > 180) {
      return res.status(400).json({
        error: "Invalid longitude. Must be between -180 and 180"
      });
    }

    // Validate required pond fields
    const requiredPondFields = [
      'pondArea', 'pondDepth', 'species', 'dateOfStocking', 
      'qtySeedInitially', 'currentQty', 'waterTemperature', 'pH', 'DO',
      'farmObservedDate', 'farmObservedTime'
    ];
    
    for (const field of requiredPondFields) {
      if (!pondData[field]) {
        return res.status(400).json({ 
          error: `Please fill required field: ${field.replace(/([A-Z])/g, ' $1').toLowerCase()}` 
        });
      }
    }

    // Upload images to GridFS
    let pondImageId = null;
    if (req.files?.pondImage?.[0]) {
      pondImageId = await uploadToGridFS(
        req.files.pondImage[0].buffer,
        req.files.pondImage[0].originalname,
        { 
          type: 'pond-image', 
          farmerId: farmer.farmerId,
          farmerName: farmer.name 
        },
        'pondImages'
      );
    } else {
      return res.status(400).json({ error: "Pond image is required" });
    }
    
    let selfieId = null;
    if (req.files?.uploadSelfie?.[0]) {
      selfieId = await uploadToGridFS(
        req.files.uploadSelfie[0].buffer,
        req.files.uploadSelfie[0].originalname,
        { 
          type: 'pond-selfie', 
          farmerId: farmer.farmerId,
          farmerName: farmer.name 
        },
        'pondImages'
      );
    }
    
    let pondFileIds = [];
    if (req.files?.pondFiles && req.files.pondFiles.length > 0) {
      pondFileIds = await uploadMultipleToGridFS(
        req.files.pondFiles,
        { 
          type: 'pond-document', 
          farmerId: farmer.farmerId,
          farmerName: farmer.name 
        },
        'documents'
      );
    }
    
    let fishFileIds = [];
    if (req.files?.fishFiles && req.files.fishFiles.length > 0) {
      fishFileIds = await uploadMultipleToGridFS(
        req.files.fishFiles,
        { 
          type: 'fish-document', 
          farmerId: farmer.farmerId,
          farmerName: farmer.name 
        },
        'documents'
      );
    }

    const pondNumber = farmer.ponds.length > 0 
      ? Math.max(...farmer.ponds.map(p => p.pondNumber)) + 1 
      : 1;
    
    const newPondId = `${farmer.farmerId}-P${pondNumber}`;

    // Parse dates
    let dateOfStocking = new Date();
    if (pondData.dateOfStocking) {
      dateOfStocking = new Date(pondData.dateOfStocking);
    }
    
    let farmObservedDate = new Date();
    if (pondData.farmObservedDate) {
      farmObservedDate = new Date(pondData.farmObservedDate);
    }

    // Create new pond object
    const newPond = {
      pondId: newPondId,
      pondNumber,
      
      pondArea: pondData.pondArea || "",
      pondAreaUnit: pondData.pondAreaUnit || "acre",
      pondDepth: pondData.pondDepth || "",
      
      pondImageId: pondImageId,
      pondImageUrl: getFileUrl(pondImageId, 'pondImages'),
      
      uploadSelfieId: selfieId,
      uploadSelfieUrl: selfieId ? getFileUrl(selfieId, 'pondImages') : null,
      
      latitude: lat,
      longitude: lng,
      
      overflow: pondData.overflow || "No",
      receivesSunlight: pondData.receivesSunlight || "Yes",
      treesOnBanks: pondData.treesOnBanks || "No",
      neighbourhood: pondData.neighbourhood || "Agriculture Farm",
      wastewaterEnters: pondData.wastewaterEnters || "No",
      
      species: pondData.species || "",
      dateOfStocking: dateOfStocking,
      qtySeedInitially: pondData.qtySeedInitially || "",
      currentQty: pondData.currentQty || "",
      avgSize: pondData.avgSize || ">200gram",
      
      feedType: pondData.feedType || "Market Feed",
      feedOther: pondData.feedOther || "",
      feedFreq: pondData.feedFreq || "Once a day",
      feedQtyPerDay: pondData.feedQtyPerDay || "",
      feedTime: pondData.feedTime || "6:00 am-10:00am",
      recentFeedChanges: pondData.recentFeedChanges || "",
      reducedAppetite: pondData.reducedAppetite || "No",
      
      waterTemperature: pondData.waterTemperature || "",
      pH: pondData.pH || "",
      DO: pondData.DO || "",
      ammoniaLevel: pondData.ammoniaLevel || "Medium",
      phytoplanktonLevel: pondData.phytoplanktonLevel || "Medium",
      waterHardness: pondData.waterHardness || "1",
      algaeBloom: pondData.algaeBloom || "No",
      pondWaterColor: pondData.pondWaterColor || "Light Green",
      sourceOfWater: pondData.sourceOfWater || "Rainwater",
      
      diseaseSymptoms: pondData.diseaseSymptoms || "No",
      symptomsObserved: pondData.symptomsObserved || "",
      fishDeaths: pondData.fishDeaths || "",
      symptomsAffect: pondData.symptomsAffect || "All",
      
      farmObservedDate: farmObservedDate,
      farmObservedTime: pondData.farmObservedTime || "",
      
      lastSpecies: pondData.lastSpecies || "",
      lastHarvestComplete: pondData.lastHarvestComplete || "Yes",
      recentRainFlood: pondData.recentRainFlood || "No",
      pesticideRunoff: pondData.pesticideRunoff || "No",
      constructionNear: pondData.constructionNear || "No",
      suddenTempChange: pondData.suddenTempChange || "No",
      
      notes: pondData.notes || "",
      
      pondFileIds: pondFileIds,
      fishFileIds: fishFileIds,
      
      createdAt: new Date(),
      updatedAt: new Date()
    };

    // Add pond to farmer
    farmer.ponds.push(newPond);
    farmer.pondCount = farmer.ponds.length;
    farmer.updatedAt = new Date();

    await farmer.save();

    // Prepare response
    const responseFarmer = farmer.toObject();
    responseFarmer.photo = responseFarmer.photoUrl;
    
    if (responseFarmer.ponds) {
      responseFarmer.ponds = responseFarmer.ponds.map(pond => ({
        ...pond,
        pondImage: pond.pondImageUrl,
        uploadSelfie: pond.uploadSelfieUrl
      }));
    }

    res.json({ 
      success: true, 
      message: "Pond added successfully",
      farmer: responseFarmer 
    });
  } catch (err) {
    console.error("ðŸ”¥ ADD POND ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// UPDATE POND
// ---------------------------
export const updatePond = async (req, res) => {
  try {
    const { farmerId, pondId } = req.params;
    const updateData = req.body;

    const farmer = await Farmer.getFarmerByAnyId(farmerId);
    if (!farmer) {
      return res.status(404).json({ error: "Farmer not found" });
    }

    const pondIndex = farmer.ponds.findIndex(p => p.pondId === pondId);
    if (pondIndex === -1) {
      return res.status(404).json({ error: "Pond not found" });
    }

    // Validate latitude/longitude if provided
    if (updateData.latitude !== undefined || updateData.longitude !== undefined) {
      const lat = updateData.latitude !== undefined ? parseFloat(updateData.latitude) : farmer.ponds[pondIndex].latitude;
      const lng = updateData.longitude !== undefined ? parseFloat(updateData.longitude) : farmer.ponds[pondIndex].longitude;
      
      if (updateData.latitude !== undefined && (isNaN(lat) || lat < -90 || lat > 90)) {
        return res.status(400).json({
          error: "Invalid latitude. Must be between -90 and 90"
        });
      }
      
      if (updateData.longitude !== undefined && (isNaN(lng) || lng < -180 || lng > 180)) {
        return res.status(400).json({
          error: "Invalid longitude. Must be between -180 and 180"
        });
      }
    }

    // Parse dates
    if (updateData.dateOfStocking) {
      updateData.dateOfStocking = new Date(updateData.dateOfStocking);
    }
    if (updateData.farmObservedDate) {
      updateData.farmObservedDate = new Date(updateData.farmObservedDate);
    }

    // Save old pond for history
    const oldPond = JSON.parse(JSON.stringify(farmer.ponds[pondIndex]));
    
    // Handle file updates
    let pondImageId = oldPond.pondImageId;
    if (req.files?.pondImage?.[0]) {
      // Delete old image
      if (oldPond.pondImageId) {
        await deleteFromGridFS(oldPond.pondImageId, 'pondImages').catch(console.error);
      }
      // Upload new
      pondImageId = await uploadToGridFS(
        req.files.pondImage[0].buffer,
        req.files.pondImage[0].originalname,
        { 
          type: 'pond-image', 
          farmerId: farmer.farmerId,
          pondId: pondId,
          updatedAt: new Date()
        },
        'pondImages'
      );
    }
    
    let selfieId = oldPond.uploadSelfieId;
    if (req.files?.uploadSelfie?.[0]) {
      if (oldPond.uploadSelfieId) {
        await deleteFromGridFS(oldPond.uploadSelfieId, 'pondImages').catch(console.error);
      }
      selfieId = await uploadToGridFS(
        req.files.uploadSelfie[0].buffer,
        req.files.uploadSelfie[0].originalname,
        { 
          type: 'pond-selfie', 
          farmerId: farmer.farmerId,
          pondId: pondId,
          updatedAt: new Date()
        },
        'pondImages'
      );
    }
    
    let pondFileIds = oldPond.pondFileIds || [];
    if (req.files?.pondFiles && req.files.pondFiles.length > 0) {
      const newFileIds = await uploadMultipleToGridFS(
        req.files.pondFiles,
        { 
          type: 'pond-document', 
          farmerId: farmer.farmerId,
          pondId: pondId,
          updatedAt: new Date()
        },
        'documents'
      );
      pondFileIds = [...pondFileIds, ...newFileIds];
    }
    
    let fishFileIds = oldPond.fishFileIds || [];
    if (req.files?.fishFiles && req.files.fishFiles.length > 0) {
      const newFileIds = await uploadMultipleToGridFS(
        req.files.fishFiles,
        { 
          type: 'fish-document', 
          farmerId: farmer.farmerId,
          pondId: pondId,
          updatedAt: new Date()
        },
        'documents'
      );
      fishFileIds = [...fishFileIds, ...newFileIds];
    }

    // Track changes
    const changes = {};
    Object.keys(updateData).forEach(key => {
      if (oldPond[key] != updateData[key]) {
        changes[`pond.${key}`] = {
          old: oldPond[key] || "N/A",
          new: updateData[key]
        };
      }
    });

    // Track file changes
    if (req.files?.pondImage?.[0]) {
      changes['pond.pondImage'] = { old: 'Previous image', new: 'New image uploaded' };
    }
    if (req.files?.uploadSelfie?.[0]) {
      changes['pond.uploadSelfie'] = { old: 'Previous selfie', new: 'New selfie uploaded' };
    }

    // Add to history
    if (Object.keys(changes).length > 0) {
      farmer.updates.push({
        snapshot: {
          pondId: oldPond.pondId,
          pondNumber: oldPond.pondNumber,
          ...oldPond
        },
        changes,
        updatedBy: updateData.userId || farmer.userId,
        createdAt: new Date()
      });
    }

    // Update pond
    const updatedPond = {
      ...oldPond,
      
      // Protected fields - never change
      pondId: oldPond.pondId,
      pondNumber: oldPond.pondNumber,
      
      // Apply updates
      ...updateData,
      
      // GridFS IDs
      pondImageId: pondImageId,
      pondImageUrl: pondImageId ? getFileUrl(pondImageId, 'pondImages') : null,
      
      uploadSelfieId: selfieId,
      uploadSelfieUrl: selfieId ? getFileUrl(selfieId, 'pondImages') : null,
      
      pondFileIds: pondFileIds,
      fishFileIds: fishFileIds,
      
      // Location (safe parsing)
      latitude: updateData.latitude !== undefined ? parseFloat(updateData.latitude) : oldPond.latitude,
      longitude: updateData.longitude !== undefined ? parseFloat(updateData.longitude) : oldPond.longitude,
      
      updatedAt: new Date()
    };

    farmer.ponds[pondIndex] = updatedPond;
    farmer.updatedAt = new Date();
    
    await farmer.save();

    // Prepare response
    const responseFarmer = farmer.toObject();
    responseFarmer.photo = responseFarmer.photoUrl;
    
    if (responseFarmer.ponds) {
      responseFarmer.ponds = responseFarmer.ponds.map(pond => ({
        ...pond,
        pondImage: pond.pondImageUrl,
        uploadSelfie: pond.uploadSelfieUrl
      }));
    }

    res.json({ 
      success: true, 
      message: "Pond updated successfully",
      farmer: responseFarmer 
    });
  } catch (err) {
    console.error("ðŸ”¥ UPDATE POND ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// DELETE POND
// ---------------------------
export const deletePond = async (req, res) => {
  try {
    const { farmerId, pondId } = req.params;

    const farmer = await Farmer.getFarmerByAnyId(farmerId);
    if (!farmer) {
      return res.status(404).json({ error: "Farmer not found" });
    }

    const pondIndex = farmer.ponds.findIndex(p => p.pondId === pondId);
    if (pondIndex === -1) {
      return res.status(404).json({ error: "Pond not found" });
    }

    const pond = farmer.ponds[pondIndex];

    // Delete all associated files from GridFS
    if (pond.pondImageId) {
      await deleteFromGridFS(pond.pondImageId, 'pondImages').catch(console.error);
    }
    if (pond.uploadSelfieId) {
      await deleteFromGridFS(pond.uploadSelfieId, 'pondImages').catch(console.error);
    }
    
    // Delete multiple files
    if (pond.pondFileIds && pond.pondFileIds.length > 0) {
      for (const fileId of pond.pondFileIds) {
        await deleteFromGridFS(fileId, 'documents').catch(console.error);
      }
    }
    
    if (pond.fishFileIds && pond.fishFileIds.length > 0) {
      for (const fileId of pond.fishFileIds) {
        await deleteFromGridFS(fileId, 'documents').catch(console.error);
      }
    }

    // Remove pond from array
    farmer.ponds.splice(pondIndex, 1);
    farmer.pondCount = farmer.ponds.length;
    farmer.updatedAt = new Date();
    
    await farmer.save();

    res.json({ 
      success: true, 
      message: "Pond deleted successfully" 
    });
  } catch (err) {
    console.error("ðŸ”¥ DELETE POND ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// DELETE FARMER
// ---------------------------
export const deleteFarmer = async (req, res) => {
  try {
    const farmer = await Farmer.findById(req.params.id);
    if (!farmer) {
      return res.status(404).json({ error: "Farmer not found" });
    }

    // Delete farmer photo
    if (farmer.photoId) {
      await deleteFromGridFS(farmer.photoId, 'documents').catch(console.error);
    }

    // Delete all pond files
    for (const pond of farmer.ponds) {
      if (pond.pondImageId) {
        await deleteFromGridFS(pond.pondImageId, 'pondImages').catch(console.error);
      }
      if (pond.uploadSelfieId) {
        await deleteFromGridFS(pond.uploadSelfieId, 'pondImages').catch(console.error);
      }
      
      if (pond.pondFileIds && pond.pondFileIds.length > 0) {
        for (const fileId of pond.pondFileIds) {
          await deleteFromGridFS(fileId, 'documents').catch(console.error);
        }
      }
      
      if (pond.fishFileIds && pond.fishFileIds.length > 0) {
        for (const fileId of pond.fishFileIds) {
          await deleteFromGridFS(fileId, 'documents').catch(console.error);
        }
      }
    }

    await Farmer.findByIdAndDelete(req.params.id);

    res.json({ 
      success: true, 
      message: "Farmer deleted successfully" 
    });
  } catch (err) {
    console.error("ðŸ”¥ DELETE FARMER ERROR:", err);
    res.status(500).json({ error: err.message });
  }
};

// ---------------------------
// EXPORT ALL FUNCTIONS
// ---------------------------
export {
  getFarmersByAgent,
  addFarmer,
  getFarmers,
  getFarmerById,
  updateFarmer,
  addPondToFarmer,
  updatePond,
  deletePond,
  deleteFarmer
};





















